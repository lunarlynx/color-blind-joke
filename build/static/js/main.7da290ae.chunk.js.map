{"version":3,"sources":["utils/render.js","WorkArea/WorkArea.jsx","App.js","reportWebVitals.js","index.js"],"names":["width","height","colorsRed","colorsGreen","getColorForUnblind","unblind","circle","includes","color","getCheckBordersText","pg","eq","get","x","y","createVirtualText","p5","text","createGraphics","background","textFont","fontSize","candidate","textSize","xStart","textWidth","yStart","dist","getFontSize","generate","acceptableRadius","colors","circles","checkBorders","totalNumber","counter","length","random","r","overlapping","i","existing","push","WorkArea","downloadPNGHandler","a","canvas","document","querySelector","img","toDataURL","createElement","href","download","click","downloadSVGHandler","convertToSvg","encodeURIComponent","useState","ourCircles","setOurCircles","setUnblind","ctx","C2S","fillStyle","beginPath","arc","Math","PI","fill","getSerializedSvg","className","onClick","setup","canvasParentRef","createCanvas","parent","noStroke","fontSizeForCircles","forBigCircles","forSmallCircles","generateSmallCircles","checkBordersCircle","generateCircles","draw","ellipse","drawAllCircles","App","inputValue","setInputValue","renderedValue","setRenderedValue","src","alt","onChange","event","target","value","substr","max","min","toUpperCase","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7da290ae.chunk.js","sourcesContent":["export const width = 700;\nexport const height = 700;\nconst protection = 50000;\n\nconst colorsRed = [\"#f49427\", \"#c9785c\", \"#fece00\", \"#f1b181\"];\nconst colorsGreen = [\"#7ba55e\", \"#89b370\", \"#b6c674\"];\n\n\n// For generate more big circles\nconst generateBigCircles = (fontSize) => {\n    return [fontSize / 20, fontSize / 25, fontSize / 30, fontSize / 35];\n}\n\n// For generate less small circles, its more beautiful, trust\nconst generateSmallCircles = (fontSize) => {\n    return [fontSize / 50, fontSize / 60];\n}\n\nexport const checkBordersCircle = (circle, p5) => {\n    return p5.dist(circle.x, circle.y, width / 2, width / 2) + circle.r <= (width / 2);\n}\n\n// Generating all circles in the text and area\nexport function generateCircles(p5, text) {\n    let circles = [];\n\n    let [pg, fontSize] = createVirtualText(p5, text);\n    let fontSizeForCircles = fontSize;\n    if (text.length <= 2) {\n        [, fontSizeForCircles] = createVirtualText(p5, \"aaa\");\n    }\n\n    //circle size is based on text length, so we need to fix circles number based on the same parameter\n    const totalNumber = text.length * 2000;\n\n    let forBigCircles = generateBigCircles(fontSizeForCircles);\n    let forSmallCircles = generateSmallCircles(fontSizeForCircles);\n    generate(p5, forBigCircles, colorsGreen, circles, getCheckBordersText(pg, true), totalNumber);\n    generate(p5, forSmallCircles, colorsGreen, circles, getCheckBordersText(pg, true), totalNumber);\n\n    let checkBorders = (circle, p5) => checkBordersCircle(circle, p5) && getCheckBordersText(pg, false)(circle);\n\n    generate(p5, forBigCircles, colorsRed, circles, checkBorders, totalNumber);\n    generate(p5, forSmallCircles, colorsRed, circles, checkBorders, totalNumber);\n    return circles;\n}\n\nexport function getColorForUnblind(unblind, circle) {\n    return unblind ? (colorsRed.includes(circle.color) ? \"#d98b8b\" : \"#000000\") : circle.color;\n}\n\nexport const drawAllCircles = (p5, circles, unblind) => {\n    for (let i = 0; i < circles.length; i++) {\n        let circle = circles[i];\n        let color = getColorForUnblind(unblind, circle);\n        p5.fill(color);\n        p5.ellipse(circle.x, circle.y,\n            circle.r * 2, circle.r * 2);\n    }\n};\n\nfunction getCheckBordersText(pg, eq) {\n    return (circle) => {\n        let ourCircleColors = pg.get(circle.x, circle.y);\n        let result = ourCircleColors[0] === 0;\n        return result === eq;\n    };\n}\nfunction createVirtualText(p5, text) {\n    const pg = p5.createGraphics(width, height);\n\n    pg.background(\"transparent\");\n    pg.textFont('Arial');\n\n    let fontSize = getFontSize(pg, text);\n    pg.textSize(fontSize);\n\n    let textWidth = pg.textWidth(text);\n    let textHeight = pg.textWidth(\"лю\");\n\n    let xStart = (width / 2) - (textWidth / 2);\n    let yStart = (height / 2) + (textHeight / 2);\n    pg.text(text, xStart, yStart);\n    return [pg, fontSize];\n}\n\nfunction getFontSize(p5, text) {\n    let candidate = 5;\n    while (true) {\n        p5.textSize(candidate + 1);\n        let textWidth = p5.textWidth(text);\n        let textHeight = p5.textWidth(\"лю\");\n        let xStart = (width / 2) - (textWidth / 2);\n        let yStart = (height / 2) + (textHeight / 2);\n\n        if (p5.dist(width / 2, height / 2, xStart, yStart) <= width / 2) {\n            candidate = candidate + 1;\n        } else {\n            return candidate;\n        }\n    }\n}\n\n\nfunction getmeSomeValue() {\n    return false;\n}\n\n/**\n *\n * @param p5 - rendering context\n * @param {Array<*>} acceptableRadius - array of possible radius depends of text size\n * @param {Array<string>} colors - array of possible colors\n * @param {Array<*>} circles - collect all circles in general array\n * @param {function(p): boolean} checkBorders - checking that the circles fit into the text\n * @param {number} totalNumber - how many circles will there be in the final drawing\n */\nexport const generate = (p5, acceptableRadius, colors, circles, checkBorders, totalNumber) => {\n    let counter = 0;\n\n    // populate circles array\n    // brute force method continues until # of circles target is reached\n    // or until the protection value is reached\n    while (circles.length < totalNumber && counter < protection) {\n        let circle = {\n            x: p5.random(width),\n            y: p5.random(height),\n            r: p5.random(acceptableRadius),\n            color: p5.random(colors)\n        };\n        let overlapping = getmeSomeValue();\n\n        if (!checkBorders(circle, p5)) {\n            overlapping = true;\n        } else {\n            for (let i = 0; i < circles.length; i++) {\n                const existing = circles[i];\n                const distance = p5.dist(circle.x, circle.y, existing.x, existing.y);\n                if (distance < circle.r + existing.r + 1) {\n                    // They are overlapping\n                    overlapping = true;\n                    // do not add to array\n                    break;\n                }\n            }\n        }\n\n        // add valid circles to array\n        if (!overlapping) {\n            circles.push(circle);\n        }\n\n        counter++;\n    }\n}\n\n","import Sketch from \"react-p5\";\nimport {useState} from \"react\";\nimport {drawAllCircles, generateCircles, getColorForUnblind, height, width} from \"../utils/render\";\nimport C2S from \"canvas2svg\";\n\nconst WorkArea = ({text}) => {\n\n    const downloadPNGHandler = async () => {\n        const canvas = document.querySelector('canvas');\n        const img = canvas.toDataURL(\"image/png\"); //converts to base64\n        const a = document.createElement(\"a\");\n        a.href = img;\n        a.download = \"imageinpng.png\";\n        a.click();\n    }\n\n    const downloadSVGHandler = async () => {\n        let img = convertToSvg();\n        const a = document.createElement(\"a\");\n        a.href = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(img);  //converts to base64\n        a.download = \"imageinsvg.svg\";\n        a.click();\n    }\n\n    const [ourCircles, setOurCircles] = useState();\n    const [unblind, setUnblind] = useState(false);\n\n    // Initialization of canvas\n    const setup = (p5, canvasParentRef) => {\n        p5.createCanvas(width, height).parent(canvasParentRef);\n        p5.background(\"transparent\")\n        p5.noStroke();\n        let circles = generateCircles(p5, text);\n        setOurCircles(circles);\n    };\n\n\n    // Draw canvas\n    const draw = (p5) => {\n        drawAllCircles(p5, ourCircles, unblind);\n    }\n\n    // Blind or not blind mode\n    const unblindHandler = () => {\n        setUnblind(!unblind);\n    }\n\n    //canvas to svg works only as an emulation:\n    //we have to render the same image but using as a context a special handler from canvas2svg C2S\n    //unfortunately it doesn't work with p5 so we have to write pure canvas code here\n    const convertToSvg = () => {\n        let ctx = new C2S(width, height);\n\n        for (let i = 0; i < ourCircles.length; i++) {\n            let circle = ourCircles[i];\n            ctx.fillStyle = getColorForUnblind(unblind, circle);\n            ctx.beginPath();\n            ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n\n        return ctx.getSerializedSvg();\n    }\n\n    return (\n        <>\n            <div className=\"download-menu\">\n                <button onClick={downloadSVGHandler}>SVG</button>\n                <button onClick={downloadPNGHandler}>PNG</button>\n                <button onClick={unblindHandler}>{unblind ? \"Blind\" : \"Unblind\"}</button>\n            </div>\n            <Sketch setup={setup} draw={draw}/>\n        </>)\n};\n\n\nexport default WorkArea;\n","import './App.css';\nimport WorkArea from './WorkArea/WorkArea';\nimport {useState} from \"react\";\n\nfunction App() {\n\n    const [inputValue, setInputValue] = useState('');\n    const [renderedValue, setRenderedValue] = useState(0);\n\n    const userWord = (event) => {\n        setInputValue(event.target.value);\n        if (event.target.value.length > 10) {\n            event.target.value = event.target.value.substr(0, 10);\n        }\n    }\n\n    const sendWord = () => {\n        setRenderedValue(renderedValue + 1);\n    }\n\n    return (\n        <div className=\"App\">\n            <div className=\"container\">\n                <div className=\"col-left\">\n                    <a href=\"#\" className=\"logo\">\n                        <img src=\"./logo.png\" alt=\"color-blind-blender logo\" width=\"50\" height=\"50\"/>\n                        <span>color-blind-blender</span>\n                    </a>\n                    <div className=\"form\">\n                        <div className=\"form-items\">\n                            <label>Enter your text:</label>\n                            <input onChange={userWord} max={10} min={1}/>\n                            <span className=\"subtitle\">max length 10 symbols</span>\n                        </div>\n                    </div>\n                    <div className=\"button-bar\">\n                        <button onClick={sendWord}>Generate!</button>\n                    </div>\n                </div>\n                <div className=\"col-right\">\n                    {renderedValue > 0 &&\n                        <WorkArea key={renderedValue} text={inputValue.toUpperCase()}/>\n                    }\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}