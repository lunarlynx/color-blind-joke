{"version":3,"sources":["utils/render.js","WorkArea/WorkArea.jsx","WorkArea/circle.worker.js","App.js","reportWebVitals.js","index.js"],"names":["width","height","colorsRed","getColorForUnblind","unblind","circle","includes","color","worker","Worker","__webpack_public_path__","drawAllCircles","p5","circles","i","length","fill","ellipse","x","y","r","WorkArea","text","useState","ourCircles","setOurCircles","useEffect","a","onmessage","event","data","postMessage","downloadPNGHandler","canvas","document","querySelector","img","toDataURL","createElement","href","download","click","downloadSVGHandler","convertToSvg","encodeURIComponent","setUnblind","ctx","C2S","fillStyle","beginPath","arc","Math","PI","getSerializedSvg","hasCircles","type","className","onClick","setup","canvasParentRef","createCanvas","parent","background","noStroke","draw","App","inputValue","setInputValue","renderedValue","setRenderedValue","src","alt","onChange","target","value","substr","max","min","toUpperCase","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.87b762fa.chunk.js","sourcesContent":["export const width = 700;\nexport const height = 700;\n\nconst protection = 50000;\nconst colorsRed = [\"#f49427\", \"#c9785c\", \"#fece00\", \"#f1b181\"];\nconst colorsGreen = [\"#7ba55e\", \"#89b370\", \"#b6c674\"];\n\n// For generate more big circles\nconst generateBigCircles = (fontSize) => {\n    return [fontSize / 20, fontSize / 25, fontSize / 30, fontSize / 35];\n}\n\n// For generate less small circles, its more beautiful, trust\nconst generateSmallCircles = (fontSize) => {\n    return [fontSize / 50, fontSize / 60];\n}\n\nexport const checkBordersCircle = (circle) => {\n    return Math.hypot(circle.x - (width / 2), circle.y - (height / 2)) + circle.r <= (width / 2)\n}\n\nfunction getRedColorOfPixel(data, circle) {\n    return data[(circle.y * (width * 4) + circle.x * 4) + 3];\n}\n\n// Generating all circles in the text and area\nexport function generateCircles(text) {\n    let circles = [];\n\n    let [ctx, fontSize] = createVirtualText(text);\n    let fontSizeForCircles = fontSize;\n    if (text.length <= 2) {\n        fontSizeForCircles = getFontSize(ctx, \"aaa\")\n    }\n\n    //circle size is based on text length, so we need to fix circles number based on the same parameter\n    const totalNumber = text.length * 2000;\n\n    let forBigCircles = generateBigCircles(fontSizeForCircles);\n    let forSmallCircles = generateSmallCircles(fontSizeForCircles);\n\n    let data = ctx.getImageData(0, 0, width, height).data;\n\n    let non = 0;\n    for (let i = 4; i < data.length; i+= 4) {\n        if (data[i] !== 0) non++;\n    }\n    console.log(\"non-zero ref pixels \" + non);\n\n    generate(forBigCircles, colorsGreen, circles, getCheckBordersText(data, false), totalNumber);\n    generate(forSmallCircles, colorsGreen, circles, getCheckBordersText(data, false), totalNumber);\n\n    let checkBorders = (circle) => checkBordersCircle(circle) && getCheckBordersText(data, true)(circle);\n    generate(forBigCircles, colorsRed, circles, checkBorders, totalNumber);\n    generate(forSmallCircles, colorsRed, circles, checkBorders, totalNumber);\n    return circles;\n}\n\nexport function getColorForUnblind(unblind, circle) {\n    return unblind ? (colorsRed.includes(circle.color) ? \"#d98b8b\" : \"#000000\") : circle.color;\n}\n\nfunction getCheckBordersText(data, eq) {\n    return (circle) => {\n        let result = getRedColorOfPixel(data, circle) === 0;\n        return result === eq;\n    };\n}\n\nfunction getFont(fontSize) {\n    return `${fontSize}px Arial`;\n}\n\nfunction createVirtualText(text) {\n    const offscreenCanvas = new OffscreenCanvas(width, height);\n    const ctx = offscreenCanvas.getContext(\"2d\");\n\n    const fontSize = getFontSize(ctx, text);\n    ctx.font = getFont(fontSize);\n\n    let textWidth = getTextWidth(ctx, text);\n    // noinspection JSSuspiciousNameCombination\n    let textHeight = getTextWidth(ctx, \"M\");\n\n    let xStart = (width / 2) - (textWidth / 2);\n    let yStart = (height / 2) + (textHeight / 2);\n    ctx.fillText(text, xStart, yStart);\n    return [ctx, fontSize];\n}\n\nfunction getTextWidth(ctx, text) {\n    return ctx.measureText(text).width;\n}\n\nfunction getFontSize(ctx, text) {\n    let candidate = 5;\n    let iterations = 0;\n    while (true) {\n        if (++iterations > 1000) throw new Error(iterations.toString())\n        ctx.font = getFont(candidate + 1);\n        let textWidth = getTextWidth(ctx, text);\n        let textHeight = getTextWidth(ctx, \"M\");\n        let xStart = (width / 2) - (textWidth / 2);\n        let yStart = (height / 2) + (textHeight / 2);\n\n        if (Math.hypot((width / 2) - xStart, (height / 2) - yStart) > width / 2) {\n            return candidate;\n        }\n        candidate = candidate + 1;\n    }\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction getRandomFromArray(array) {\n    return array[getRandomInt(array.length)]\n}\n\n/**\n *\n * @param {Array<*>} acceptableRadius - array of possible radius depends of text size\n * @param {Array<string>} colors - array of possible colors\n * @param {Array<*>} circles - collect all circles in general array\n * @param {function(any): boolean} checkBorders - checking that the circles fit into the text\n * @param {number} totalNumber - how many circles will there be in the final drawing\n */\nexport const generate = (acceptableRadius, colors, circles, checkBorders, totalNumber) => {\n    let counter = 0;\n\n    // populate circles array\n    // brute force method continues until # of circles target is reached\n    // or until the protection value is reached\n    while (circles.length < totalNumber && counter < protection) {\n        let circle = {\n            x: getRandomInt(width),\n            y: getRandomInt(height),\n            r: getRandomFromArray(acceptableRadius),\n            color: getRandomFromArray(colors)\n        };\n        let overlapping = false;\n\n        if (!checkBorders(circle)) {\n            overlapping = true;\n        } else {\n            for (let i = 0; i < circles.length; i++) {\n                const existing = circles[i];\n                const distance = Math.hypot(circle.x - existing.x, circle.y - existing.y);\n                if (distance < circle.r + existing.r + 1) {\n                    // They are overlapping\n                    overlapping = true;\n                    // do not add to array\n                    break;\n                }\n            }\n        }\n\n        // add valid circles to array\n        if (!overlapping) {\n            circles.push(circle);\n        }\n\n        counter++;\n    }\n}\n\n","import Sketch from \"react-p5\";\nimport {useEffect, useState} from \"react\";\nimport {getColorForUnblind, height, width} from \"../utils/render\";\nimport C2S from \"canvas2svg\";\nimport Worker from \"./circle.worker\";\nimport Loader from \"react-loader-spinner\";\n\nconst worker = new Worker();\n\nconst WorkArea = ({text}) => {\n        const [ourCircles, setOurCircles] = useState([]);\n\n        useEffect(() => {\n            (async () => {\n\n                worker.onmessage = (event) => {\n                    const {circles} = event.data;\n                    setOurCircles(circles);\n                }\n                worker.postMessage({text});\n            })();\n        }, []);\n\n        const downloadPNGHandler = async () => {\n            const canvas = document.querySelector('canvas');\n            const img = canvas.toDataURL(\"image/png\"); //converts to base64\n            const a = document.createElement(\"a\");\n            a.href = img;\n            a.download = \"imageinpng.png\";\n            a.click();\n        }\n\n        const downloadSVGHandler = async () => {\n            let img = convertToSvg();\n            const a = document.createElement(\"a\");\n            a.href = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(img);  //converts to base64\n            a.download = \"imageinsvg.svg\";\n            a.click();\n        }\n\n\n        const [unblind, setUnblind] = useState(false);\n\n        // Initialization of canvas\n        const setup = (p5, canvasParentRef) => {\n            p5.createCanvas(width, height).parent(canvasParentRef);\n            p5.background(\"transparent\")\n            p5.noStroke();\n        };\n\n\n        // Draw canvas\n        const draw = (p5) => {\n            drawAllCircles(p5, ourCircles, unblind);\n        }\n\n        // Blind or not blind mode\n        const unblindHandler = () => {\n            setUnblind(!unblind);\n        }\n\n        //canvas to svg works only as an emulation:\n        //we have to render the same image but using as a context a special handler from canvas2svg C2S\n        //unfortunately it doesn't work with p5 so we have to write pure canvas code here\n        const convertToSvg = () => {\n            let ctx = new C2S(width, height);\n\n            for (let i = 0; i < ourCircles.length; i++) {\n                let circle = ourCircles[i];\n                ctx.fillStyle = getColorForUnblind(unblind, circle);\n                ctx.beginPath();\n                ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n\n            return ctx.getSerializedSvg();\n        }\n\n        const hasCircles = ourCircles.length > 0;\n\n        return (\n            <>\n                {!hasCircles && <Loader\n                    type=\"Grid\"\n                    color=\"#b47878\"\n                    height={100}\n                    width={100}\n                />}\n\n                {hasCircles &&\n                <>\n                    <div className=\"download-menu\">\n                        <button onClick={downloadSVGHandler}>SVG</button>\n                        <button onClick={downloadPNGHandler}>PNG</button>\n                        <button onClick={unblindHandler}>{unblind ? \"Blind\" : \"Unblind\"}</button>\n                    </div>\n                    <Sketch setup={setup} draw={draw}/>\n                </>\n                }\n            </>)\n    }\n;\n\nexport const drawAllCircles = (p5, circles, unblind) => {\n    for (let i = 0; i < circles.length; i++) {\n        let circle = circles[i];\n        let color = getColorForUnblind(unblind, circle);\n        p5.fill(color);\n        p5.ellipse(circle.x, circle.y,\n            circle.r * 2, circle.r * 2);\n    }\n};\n\n\nexport default WorkArea;\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/circle.worker.f8d57d98.worker.js\");\n}\n","import './App.css';\nimport WorkArea from './WorkArea/WorkArea';\nimport {useState} from \"react\";\n\nfunction App() {\n\n    const [inputValue, setInputValue] = useState('');\n    const [renderedValue, setRenderedValue] = useState(0);\n\n    const userWord = (event) => {\n        setInputValue(event.target.value);\n        if (event.target.value.length > 10) {\n            event.target.value = event.target.value.substr(0, 10);\n        }\n    }\n\n    const sendWord = () => {\n        setRenderedValue(renderedValue + 1);\n    }\n\n    return (\n        <div className=\"App\">\n            <div className=\"container\">\n                <div className=\"col-left\">\n                    <a href=\"#\" className=\"logo\">\n                        <img src=\"./logo.png\" alt=\"color-blind-blender logo\" width=\"50\" height=\"50\"/>\n                        <span>color-blind-blender</span>\n                    </a>\n                    <div className=\"form\">\n                        <div className=\"form-items\">\n                            <label>Enter your text:</label>\n                            <input onChange={userWord} max={10} min={1}/>\n                            <span className=\"subtitle\">max length 10 symbols</span>\n                        </div>\n                    </div>\n                    <div className=\"button-bar\">\n                        <button onClick={sendWord}>Generate!</button>\n                    </div>\n                </div>\n                <div className=\"col-right\">\n                    {renderedValue > 0 &&\n                        <WorkArea key={renderedValue} text={inputValue.toUpperCase()}/>\n                    }\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}