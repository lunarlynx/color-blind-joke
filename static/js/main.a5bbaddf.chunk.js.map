{"version":3,"sources":["WorkArea/circle.worker.js","utils/render.js","App.js","reportWebVitals.js","index.js","WorkArea/WorkArea.jsx"],"names":["Worker_fn","Worker","__webpack_public_path__","width","height","colorsRed","colorsGreen","generateBigCircles","fontSize","generateSmallCircles","checkBordersCircle","circle","Math","hypot","x","y","r","generateCircles","text","ctx","getContext","circles","fontSizeForCircles","createVirtualText","length","getFontSize","totalNumber","forBigCircles","forSmallCircles","data","getImageData","non","i","console","log","generate","getCheckBordersText","checkBorders","getColorForUnblind","unblind","includes","color","eq","getRedColorOfPixel","getFont","OffscreenCanvas","font","textWidth","getTextWidth","textHeight","xStart","yStart","fillText","measureText","candidate","iterations","Error","toString","getRandomInt","max","floor","random","getRandomFromArray","array","acceptableRadius","colors","counter","overlapping","existing","push","App","useState","inputValue","setInputValue","renderedValue","setRenderedValue","className","href","src","alt","onChange","event","target","value","substr","min","onClick","WorkArea","toUpperCase","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","worker","drawAllCircles","p5","fill","ellipse","ourCircles","setOurCircles","useEffect","global","canvas","createElement","createFakeContext","a","onmessage","postMessage","downloadPNGHandler","querySelector","img","toDataURL","download","click","downloadSVGHandler","convertToSvg","encodeURIComponent","setUnblind","C2S","fillStyle","beginPath","arc","PI","getSerializedSvg","hasCircles","type","setup","canvasParentRef","createCanvas","parent","background","noStroke","draw"],"mappings":"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","file":"static/js/main.a5bbaddf.chunk.js","sourcesContent":["export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/circle.worker.ef29a1ba.worker.js\");\n}\n","export const width = 700;\nexport const height = 700;\n\nconst protection = 50000;\nconst colorsRed = [\"#f49427\", \"#c9785c\", \"#fece00\", \"#f1b181\"];\nconst colorsGreen = [\"#7ba55e\", \"#89b370\", \"#b6c674\"];\n\n// For generate more big circles\nconst generateBigCircles = (fontSize) => {\n    return [fontSize / 20, fontSize / 25, fontSize / 30, fontSize / 35];\n}\n\n// For generate less small circles, its more beautiful, trust\nconst generateSmallCircles = (fontSize) => {\n    return [fontSize / 50, fontSize / 60];\n}\n\nexport const checkBordersCircle = (circle) => {\n    return Math.hypot(circle.x - (width / 2), circle.y - (height / 2)) + circle.r <= (width / 2)\n}\n\nfunction getRedColorOfPixel(data, circle) {\n    return data[(circle.y * (width * 4) + circle.x * 4) + 3];\n}\n\n// Generating all circles in the text and area\nexport function generateCircles(text, ctx = getContext()) {\n    let circles = [];\n\n    let fontSizeForCircles = createVirtualText(ctx, text);\n    if (text.length <= 2) {\n        fontSizeForCircles = getFontSize(ctx, \"aaa\")\n    }\n\n    //circle size is based on text length, so we need to fix circles number based on the same parameter\n    const totalNumber = text.length * 2000;\n\n    let forBigCircles = generateBigCircles(fontSizeForCircles);\n    let forSmallCircles = generateSmallCircles(fontSizeForCircles);\n\n    let data = ctx.getImageData(0, 0, width, height).data;\n\n    let non = 0;\n    for (let i = 3; i < data.length; i += 4) {\n        if (data[i] !== 0) non++;\n    }\n    console.log(\"non-zero ref pixels \" + non);\n\n    generate(forBigCircles, colorsGreen, circles, getCheckBordersText(data, false), totalNumber);\n    generate(forSmallCircles, colorsGreen, circles, getCheckBordersText(data, false), totalNumber);\n\n    let checkBorders = (circle) => checkBordersCircle(circle) && getCheckBordersText(data, true)(circle);\n    generate(forBigCircles, colorsRed, circles, checkBorders, totalNumber);\n    generate(forSmallCircles, colorsRed, circles, checkBorders, totalNumber);\n    return circles;\n}\n\nexport function getColorForUnblind(unblind, circle) {\n    return unblind ? (colorsRed.includes(circle.color) ? \"#d98b8b\" : \"#000000\") : circle.color;\n}\n\nfunction getCheckBordersText(data, eq) {\n    return (circle) => {\n        let result = getRedColorOfPixel(data, circle) === 0;\n        return result === eq;\n    };\n}\n\nfunction getFont(fontSize) {\n    return `${fontSize}px Arial`;\n}\n\nfunction getContext() {\n    const offscreenCanvas = new OffscreenCanvas(width, height);\n    return offscreenCanvas.getContext(\"2d\");\n}\n\nfunction createVirtualText(ctx, text) {\n    const fontSize = getFontSize(ctx, text);\n    ctx.font = getFont(fontSize);\n\n    let textWidth = getTextWidth(ctx, text);\n    // noinspection JSSuspiciousNameCombination\n    let textHeight = getTextWidth(ctx, \"M\");\n\n    let xStart = (width / 2) - (textWidth / 2);\n    let yStart = (height / 2) + (textHeight / 2);\n    ctx.fillText(text, xStart, yStart);\n    return fontSize;\n}\n\nfunction getTextWidth(ctx, text) {\n    return ctx.measureText(text).width;\n}\n\nfunction getFontSize(ctx, text) {\n    let candidate = 5;\n    let iterations = 0;\n    while (true) {\n        if (++iterations > 1000) throw new Error(iterations.toString())\n        ctx.font = getFont(candidate + 1);\n        let textWidth = getTextWidth(ctx, text);\n        let textHeight = getTextWidth(ctx, \"M\");\n        let xStart = (width / 2) - (textWidth / 2);\n        let yStart = (height / 2) + (textHeight / 2);\n\n        if (Math.hypot((width / 2) - xStart, (height / 2) - yStart) > width / 2) {\n            return candidate;\n        }\n        candidate = candidate + 1;\n    }\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction getRandomFromArray(array) {\n    return array[getRandomInt(array.length)]\n}\n\n/**\n *\n * @param {Array<*>} acceptableRadius - array of possible radius depends of text size\n * @param {Array<string>} colors - array of possible colors\n * @param {Array<*>} circles - collect all circles in general array\n * @param {function(any): boolean} checkBorders - checking that the circles fit into the text\n * @param {number} totalNumber - how many circles will there be in the final drawing\n */\nexport const generate = (acceptableRadius, colors, circles, checkBorders, totalNumber) => {\n    let counter = 0;\n\n    // populate circles array\n    // brute force method continues until # of circles target is reached\n    // or until the protection value is reached\n    while (circles.length < totalNumber && counter < protection) {\n        let circle = {\n            x: getRandomInt(width),\n            y: getRandomInt(height),\n            r: getRandomFromArray(acceptableRadius),\n            color: getRandomFromArray(colors)\n        };\n        let overlapping = false;\n\n        if (!checkBorders(circle)) {\n            overlapping = true;\n        } else {\n            for (let i = 0; i < circles.length; i++) {\n                const existing = circles[i];\n                const distance = Math.hypot(circle.x - existing.x, circle.y - existing.y);\n                if (distance < circle.r + existing.r + 1) {\n                    // They are overlapping\n                    overlapping = true;\n                    // do not add to array\n                    break;\n                }\n            }\n        }\n\n        // add valid circles to array\n        if (!overlapping) {\n            circles.push(circle);\n        }\n\n        counter++;\n    }\n}\n\n","import './App.css';\nimport WorkArea from './WorkArea/WorkArea';\nimport {useState} from \"react\";\n\nfunction App() {\n\n    const [inputValue, setInputValue] = useState('');\n    const [renderedValue, setRenderedValue] = useState(0);\n\n    const userWord = (event) => {\n        setInputValue(event.target.value);\n        if (event.target.value.length > 10) {\n            event.target.value = event.target.value.substr(0, 10);\n        }\n    }\n\n    const sendWord = () => {\n        setRenderedValue(renderedValue + 1);\n    }\n\n    return (\n        <div className=\"App\">\n            <div className=\"container\">\n                <div className=\"col-left\">\n                    <a href=\"#\" className=\"logo\">\n                        <img src=\"./logo.png\" alt=\"color-blind-blender logo\" width=\"50\" height=\"50\"/>\n                        <span>color-blind-blender</span>\n                    </a>\n                    <div className=\"form\">\n                        <div className=\"form-items\">\n                            <label>Enter your text:</label>\n                            <input onChange={userWord} max={10} min={1}/>\n                            <span className=\"subtitle\">max length 10 symbols</span>\n                        </div>\n                    </div>\n                    <div className=\"button-bar\">\n                        <button onClick={sendWord}>Generate!</button>\n                    </div>\n                </div>\n                <div className=\"col-right\">\n                    {renderedValue > 0 &&\n                        <WorkArea key={renderedValue} text={inputValue.toUpperCase()}/>\n                    }\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import Sketch from \"react-p5\";\nimport {useEffect, useState} from \"react\";\nimport {generateCircles, getColorForUnblind, height, width} from \"../utils/render\";\nimport C2S from \"canvas2svg\";\nimport Worker from \"./circle.worker\";\nimport Loader from \"react-loader-spinner\";\n\nconst worker = new Worker();\n\nfunction createFakeContext() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas.getContext(\"2d\");\n}\n\nconst WorkArea = ({text}) => {\n        const [ourCircles, setOurCircles] = useState([]);\n\n        useEffect(() => {\n            if (typeof OffscreenCanvas == \"undefined\" ||\n                typeof global.Worker == \"undefined\") {\n                setOurCircles(generateCircles(text, createFakeContext()))\n            } else {\n                (async () => {\n                    worker.onmessage = (event) => {\n                        const {circles} = event.data;\n                        setOurCircles(circles);\n                    }\n\n                    worker.postMessage({text});\n                })();\n            }\n        }, []);\n\n        const downloadPNGHandler = async () => {\n            const canvas = document.querySelector('canvas');\n            const img = canvas.toDataURL(\"image/png\"); //converts to base64\n            const a = document.createElement(\"a\");\n            a.href = img;\n            a.download = \"imageinpng.png\";\n            a.click();\n        }\n\n        const downloadSVGHandler = async () => {\n            let img = convertToSvg();\n            const a = document.createElement(\"a\");\n            a.href = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(img);  //converts to base64\n            a.download = \"imageinsvg.svg\";\n            a.click();\n        }\n\n\n        const [unblind, setUnblind] = useState(false);\n\n        // Initialization of canvas\n        const setup = (p5, canvasParentRef) => {\n            p5.createCanvas(width, height).parent(canvasParentRef);\n            p5.background(\"transparent\")\n            p5.noStroke();\n        };\n\n\n        // Draw canvas\n        const draw = (p5) => {\n            drawAllCircles(p5, ourCircles, unblind);\n        }\n\n        // Blind or not blind mode\n        const unblindHandler = () => {\n            setUnblind(!unblind);\n        }\n\n        //canvas to svg works only as an emulation:\n        //we have to render the same image but using as a context a special handler from canvas2svg C2S\n        //unfortunately it doesn't work with p5 so we have to write pure canvas code here\n        const convertToSvg = () => {\n            let ctx = new C2S(width, height);\n\n            for (let i = 0; i < ourCircles.length; i++) {\n                let circle = ourCircles[i];\n                ctx.fillStyle = getColorForUnblind(unblind, circle);\n                ctx.beginPath();\n                ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n\n            return ctx.getSerializedSvg();\n        }\n\n        const hasCircles = ourCircles.length > 0;\n\n        return (\n            <>\n                {!hasCircles && <Loader\n                    type=\"Grid\"\n                    color=\"#b47878\"\n                    height={100}\n                    width={100}\n                />}\n\n                {hasCircles &&\n                <>\n                    <div className=\"download-menu\">\n                        <button onClick={downloadSVGHandler}>SVG</button>\n                        <button onClick={downloadPNGHandler}>PNG</button>\n                        <button onClick={unblindHandler}>{unblind ? \"Blind\" : \"Unblind\"}</button>\n                    </div>\n                    <Sketch setup={setup} draw={draw}/>\n                </>\n                }\n            </>)\n    }\n;\n\nexport const drawAllCircles = (p5, circles, unblind) => {\n    for (let i = 0; i < circles.length; i++) {\n        let circle = circles[i];\n        let color = getColorForUnblind(unblind, circle);\n        p5.fill(color);\n        p5.ellipse(circle.x, circle.y,\n            circle.r * 2, circle.r * 2);\n    }\n};\n\n\nexport default WorkArea;\n"],"sourceRoot":""}